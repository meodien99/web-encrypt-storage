import { encode, generateNonce, getCryptoObject, isTypedArray } from "./crypto.utils";
import { AlgorithmParam, DeriveAlgorithm, DeriveAlgorithmParam, ImportAlgorithm, KeyUsage } from "./crypto.type";

interface IGenerateCryptoKeyParams {
  raw: string | BufferSource | JsonWebKey,
  // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm
  algorithm?: ImportAlgorithm,
  keyUsages?: KeyUsage[],
  format?: KeyFormat
}

/**
 * Create a Base Key from the original raw value.
 * This base key by default should be used to protect the original key to be discovery
 * and should not be used directly to any encrypt/decrypt algorithm.
 * The generated Base Key should be used just to derive new one.
 *
 * @param options
 * @param raw: string | BufferSource | JsonWebKey
 * @param algorithm <optional> Support those algorithms https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm
 * @param keyUsages <optional> KeyUsage[]
 * @param format <optional> KeyFormat
 *
 * @returns
 */
export function generateCryptoKey({
  raw,
  algorithm = 'PBKDF2',
  keyUsages = ['deriveKey'],
  format = 'raw'
}: IGenerateCryptoKeyParams): Promise<CryptoKey> {
  const isJWK = !isTypedArray(raw) && typeof raw === "object";

  const result = isJWK ? getCryptoObject().subtle.importKey(
    'jwk',
    raw,
    algorithm,
    false, // original value is non-extractable
    keyUsages
  ) : getCryptoObject().subtle.importKey(
    format as Exclude<KeyFormat, 'jwk'>,
    typeof raw === 'string' ? encode(raw) : raw,
    algorithm,
    false,
    keyUsages
  );

  return Promise.resolve(result);
}

/**
 *
 * or any other possibility uses in KeyUsage
 */
/**
 * Params 1
 * @param key
 * @param salt The value to be used with the default `PBKDF2` derive algorithm
 * @param iterations Default number of iterations to be used with `PBKDF2`.
 * @param keyUsages The new uses of the new derive Crypto Key. Default value: `['encrypt', 'decrypt']`
 *
 * @returns A promise with the derived Crypto Key for other uses.
 */
/**
 * Params 2
 * @param key
 * @param deriveAlgorithm The algorithm to be used when deriving the Crypto Key
 * @param algorithmParam The algorithm where the derived Crypto Key will be used. Default value: `{ name: 'AES-GCM', length: 256 }`
 * @param keyUsages
 */
interface IDeriveCryptoKeyParams {
  key: CryptoKey,
  saltOrDeriveAlgorithm: BufferSource | DeriveAlgorithm,
  iterationsOrAlgorithmParam?: number | DeriveAlgorithmParam,
  keyUsages?: KeyUsage[]
};
/**
 * Derives a Key (from generateCryptoKey) to new one that can be used to encrypt/decrypt
 *
 * @param options
 * @param key CryptoKey generated by `generateCryptoKey`
 * @param deriveAlgorithm The algorithm to be used when deriving the Crypto Key
 * @param algorithmParam The algorithm where the derived Crypto Key will be used. Default value: `{ name: 'AES-GCM', length: 256 }`
 * @param keyUsages
 * @returns
 */
export function deriveKey({
  key,
  saltOrDeriveAlgorithm,
  iterationsOrAlgorithmParam = 50000,
  keyUsages = ['encrypt', 'decrypt']
}: IDeriveCryptoKeyParams): Promise<CryptoKey> {
  const isSalt = isTypedArray(saltOrDeriveAlgorithm);
  const isIterations = typeof iterationsOrAlgorithmParam === 'number';

  const deriveAlgorithm: DeriveAlgorithm = isSalt ? ({
    name: 'PBKDF2',
    hash: 'SHA-256',
    salt: saltOrDeriveAlgorithm,
    iterations: isIterations ? iterationsOrAlgorithmParam : 100000
  }) as Pbkdf2Params : saltOrDeriveAlgorithm;

  const algorithmParam: DeriveAlgorithmParam = isIterations ? ({
    name: 'AES-GCM',
    length: 256
  }) as AesDerivedKeyParams : iterationsOrAlgorithmParam;

  return Promise.resolve(
    getCryptoObject().subtle.deriveKey(
      deriveAlgorithm,
      key,
      algorithmParam,
      false,
      keyUsages
    )
  );
}


/**
 * Encrypt a value with the given Crypto Key & Algorithm
 *
 * @param data.
 * @param key The Crypto Key to be used in encryption.
 * @param algorithm The algorithm to be used in encryption. Default to `AES-GCM`.
 *
 * @returns A Promise with the encrypted value & used nonce (if alogirhtm provided).
 */
interface IEncryptParams {
  data: string | BufferSource,
  key: CryptoKey,
  algorithm?: AlgorithmParam
};
export function encrypt({
  data,
  key,
  algorithm = { name: 'AES-GCM', iv: generateNonce() } as AesGcmParams
}: IEncryptParams): Promise<[ArrayBuffer, BufferSource | null]> {
  return Promise.resolve(
    getCryptoObject().subtle.encrypt(algorithm, key, encode(data))
  ).then((cryptoValue) => {
    return [cryptoValue, typeof algorithm === 'object' && 'iv' in algorithm ? algorithm.iv : null];
  });
}

/**
 * Decrypt a value with the Crypto key & Algorithm.
 *
 * @param data
 * @param key
 * @param nonceOrAlgorithm The nonce used for AES encryption or custom algorithm.
 *
 * @returns A Promise with the decrypted data.
 */
interface IDecryptParams {
  data: BufferSource,
  key: CryptoKey,
  nonceOrAlgorithm: AlgorithmParam | BufferSource
};
export function decrypt({
  data,
  key,
  nonceOrAlgorithm
}: IDecryptParams): Promise<ArrayBuffer> {
  const algorithm = isTypedArray(nonceOrAlgorithm) ? ({
    name: 'AES-GCM',
    iv: nonceOrAlgorithm
  } as AesGcmParams) : nonceOrAlgorithm;

  return Promise.resolve(
    getCryptoObject().subtle.decrypt(algorithm, key, data)
  );
}
